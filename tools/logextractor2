#!/usr/local/bin/perl
# ---------------- if post apr 2018, using MaxMind mmdb data from http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.tar.gz
# ---------------- this version needs GeoIP2::Database::Reader installed
# ---------------- if XS is to be used, install MaxMind::DB::Reader::XS and Try::Tiny, and
# ---------------- install libmaxminddb library (http://maxmind.github.io/libmaxminddb/releases) or use apt
#####################################################################
#
# Web Log Extractor
#
# Reads an NCSA [combined] web server log and extracts a day's worth of data.
# Optionally does reverse DNS lookup on numeric IPs.
# Optionally does geoip lookup on numeric IPs, either via database or CSV file.
#
# logextractor2 [-dns cachefile] [-geoipcity citydatafile] -day mm/dd/yyyy filepath ... > outpath
# logextractor2 [-dns cachefile] [-geoipcity citydatafile] -day yyyy-mm-dd filepath ... > outpath
# logextractor2 [-dns cachefile] [-geoipcity citydatafile] -day yesterday filepath ... > outpath
# logextractor2 [-dns cachefile] [-geoipcity citydatafile] -day all filepath ... > outpath
#
# if the citydatafile ends in .mmdb then we use the GeoIP2 interface
#
# Finds all log entries that occurred on the given day and writes them to stdout.
#
# 07/23/04 THVV 1.0
# 08/25/04 THVV 1.1 Add geoip processing.
# 03/30/06 THVV 1.2 Add -v and allow size of "-"
# 04/11/06 THVV 1.21 Handle escaped quote in quoted strings.
# 04/27/07 THVV 1.3 Add databse lookup for super geoip.
# 05/14/07 THVV 1.31 Do super geoip if we can extract an IP from the domain.
# 05/14/07 THVV 1.4 Vastly speed up super geoip.
# 10/24/09 THVV 1.41 handle airtelbroadband.in and in-addr.arpa in geoip
# 11/26/09 THVV 1.42 handle airtel.in in geoip
# 10/25/17 THVV 1.43 prevent too-long TLDs 
# 08/23/18 THVV 2.0 remove support for the old database format, add support for the new new format, kill non-ascii

#  Permission is hereby granted, free of charge, to any person obtaining
#  a copy of this software and associated documentation files (the
#  "Software"), to deal in the Software without restriction, including
#  without limitation the rights to use, copy, modify, merge, publish,
#  distribute, sublicense, and/or sell copies of the Software, and to
#  permit persons to whom the Software is furnished to do so, subject to
#  the following conditions:
 
#  The above copyright notice and this permission notice shall be included
#  in all copies or substantial portions of the Software.
 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
#  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
#  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
#  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

use strict;

my $version = '2.0';
my $me ='logextractor2';

if ($#ARGV < 2) {
    die "$me $version: too few arguments";
}

my %v = ();

my $option_verbose = 0;
my $option_dns = 0;
my $option_geoip_city = 0;
my $selectyyyy = 0;
my $selectmmm = '';
my $selectdd = 0;
my $geoip_citydatafile = '';
my $dnscachefile = '';

my $mm = 0;
my $have_read_dns_cache = 0;    # flag if read dnscache, do it once only

my %geoipcache = ();		# separate cache for GEOIP results, discarded after each run

while ($#ARGV >= 0) {
    my $arg = shift;
    if ($arg eq "-day") {
	my $indate = shift;
	if ($indate =~ /(\d+)\/(\d+)\/(\d\d\d\d)/) {
	    $mm = int($1);
	    $selectdd = int($2);
	    $selectyyyy = $3;
	} elsif ($indate =~ /(\d\d\d\d)-(\d+)-(\d+)/) {
	    $selectyyyy = $1;
	    $mm = int($2);
	    $selectdd = int($3);
	} elsif ($indate eq "all") {
	    $selectyyyy = -1;
	} elsif ($indate eq "yesterday") {
	    my $ONEDAY = 86400;
	    my $hour = 0;
	    my $sec = 0;
	    my $min = 0;
	    my $wday = 0;
	    my $yday = 0;
	    my $isdst = 0;
	    ($sec,$min,$hour,$selectdd,$mm,$selectyyyy,$wday,$yday,$isdst) = localtime(time - $ONEDAY);
	    $selectyyyy += 1900;	# Perl year is 101 for 2001.
	    $mm++;		# Perl month was 0-11
	} else {
	    die "$me: invalid date format $indate";
	}
	my @moname = ('','Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');
	$selectmmm = $moname[$mm];
    } elsif ($arg eq "-v") {
	$option_verbose = 1;
    } elsif ($arg eq "-dns") {
	$option_dns = 1;
	$dnscachefile = shift;
    } elsif ($arg eq "-geoipcity") {
	$option_geoip_city = 1;
	$geoip_citydatafile = shift; # pathname of Maxmind city database (binary)
    } else { # not control arg, must be filename 
	if ($selectyyyy == 0) {
	    die "$me: -day not specified";
	}
	#print "$arg $selectyyyy $selectmmm $selectdd\n";
	&process_one_file($arg, $selectyyyy, $selectmmm, &twodigit($selectdd));
    }
} # while
&writednscache($dnscachefile) if $option_dns;
exit(0);

#----------------------------------------------------------------
# Process one log file

sub process_one_file {
    my $the_log_file = shift;
    my $selectyyyy = shift;
    my $selectmmm = shift;
    my $selectdd = shift;

    my $cursor;
    my $itemx;
    my $ex;
    my $junk;
    my @items;

    if ($the_log_file =~ /\.gz$|\.z$/i) {
	open(LOG, "gzcat $the_log_file |") or return;
    } else {
	open(LOG, "$the_log_file") or return;
    }

    while(<LOG>) { # scan the file
        
# parse each line into tokens delimited by space.
# tokens may be quoted or bracketed if they contain spaces.
        
        chop;
        my $line = $_;

	$cursor = 0;
        $itemx = 0;
        while ($cursor < length($line)) {
            while (substr($line, $cursor, 1) eq ' ') {
            	$cursor++;	# kill leading blanks
            }
            if (substr($line, $cursor, 1) eq '"') { # quoted string
	        # inside this string, backslash-quote should be preserved
	        my $ws = '';
		my $more = 1;
		$cursor++;
		while (($more == 1) && ($cursor < length($line))) {
		    if (substr($line, $cursor, 2) eq '\\"') {
			$ws .= '\\"';
			$cursor++; # extra bump
		    } elsif (substr($line, $cursor, 1) eq '"') {
			$more = 0;
		    } else {
			$ws .= substr($line, $cursor, 1);
		    }
		    $cursor++;
		}
            	$items[$itemx++] = $ws;
            } # quoted string
            elsif (substr($line, $cursor,1) eq '[') { # bracketed string
            	$ex = index(substr($line, $cursor+1), ']');
            	if ($ex < 0) {$ex = length($line)-$cursor}
            	$items[$itemx++] = substr($line, $cursor+1, $ex);
            	$cursor += $ex+2;
            } # bracketed string
            else { # space delimited string
            	$ex = index(substr($line, $cursor), ' ');
            	if ($ex < 0) {$ex = length($line)-$cursor}
            	$items[$itemx++] = substr($line, $cursor, $ex);
            	$cursor += $ex;
            } # space delimited string
        } # while cursor
	next if !defined($items[0]);
        
# Record is split into $items.  Interpret and normalize fields.
# Standard form: DOMAIN DIR - TIME COMMAND RETCODE SIZE [REFERRER] [BROWSER]
        
        my $referrer = '-';
	my $browser = '-';
	my $query = '-';
	my $engine = '-';
	my $verb = '';
        my $domain = $items[0];	# where the hit came from
        my $accessed_dir = $items[1]; # dirname accessed
        my $userid = $items[2]; # userid if basic auth
        my $access_time = $items[3]; # time of the hit
        my $command = $items[4]; # HTTP command, e.g. "GET pathname protocol"
	my $cmdv = "";
	my $cpath = "";
	my $cproto = "";
	($cmdv, $cpath, $cproto) = split(/ +/, $command, 3); # new check that cmd, path, proto are nonblank
	if (($cmdv eq "") || ($cpath eq "") || ($cproto eq "")) {
	    warn "$me: bad command: $line\n" if $option_verbose;
	    next;		# skip processing of record
	}
        my $retcode = $items[5]; # HTTP ERROR code
	if (!($retcode =~ /^[0-9]+$/)) { # retcode should be all digits
	    warn "$me: bad code: $line\n" if $option_verbose;
	    next;		# end processing of record
	}
        my $size = $items[6];	# size in bytes
	$size = 0 if $size eq '-'; # 304 responses may have a size of hyphen
	if ($size !~ /^\d+$/) {  # Skip this hit if size is not numeric.. ill formed hit record
	    warn "$me: bad size: $line\n" if $option_verbose;
	    next;		  # end processing of record
	}
        if ($itemx > 6) { # if there is a referrer string in the log
	    $referrer = $items[7];
	    $referrer = '-' if $referrer eq '';
        } # if there is a referrer string in the log

        if ($itemx > 7) { # if there is a browser string in the log
	    $browser = $items[8];
        } # if there is a browser string in the log

# Normalize domain and do reverse DNS and geoip if wanted.

	$domain =~ s/\.+$//; # Remove trailing dots from domain
	my $geoip = '';
	if ($domain =~ /^(.*)\[(.*)\]$/) { # do we have geoip already
	    $geoip = $2;	# has some upstream logextractor already done this?
	    $domain = $1;	# .. if so, just repeat its result, do not improve it
	} else {
	    # if super geoip mode is on, try to get a location
	    $geoip = &lookup_super_geoip($domain, \%v) if $option_geoip_city;
	    if ($domain =~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) { # if numeric
		$domain = &reversedns($domain, $dnscachefile) if $option_dns;
	    }
	}
	my $tld = $domain;	# Normalize toplevel domain.
	$tld =~ tr/A-Z/a-z/;
	my $cursor = rindex ($domain, '.');    # tld begins with last dot
	if ($cursor >= 0) {
	    $tld = substr($tld, $cursor);      # toplevel domain
	    my $bod = substr($domain, 0, $cursor);   # first part of domain
	    if ($tld =~ /^(\.[a-z]+)-(.*)$/) { # if domain is like "jobqueue-listener.jobqueue.netcraft.com-uf7914b9c5bf44d7f9d2603993738c0a3u-digitalocean"
		$tld = $1;
		#warn "$me: fixed TLD $tld DOM $domain\n";
	    }
	    if (length($tld) > 16) { # too long a TLD crashes SQL in ugly way
		#warn "$me: bad TLD $tld\n";
		$tld = substr($tld,0,16);   # brute force solution
	    }
	    $domain = $bod . $tld;	    # put in nicer TLD
	}
	if ($domain =~ /^\.\d*$/) { # if domain all digits and dots, ie reversedns didn't work
	    if ($geoip ne '') {
		$domain .= '['.$geoip.']'; # domain gets geoip appended if there is any
	    }
	} elsif (($geoip ne '') && ($tld ne ('.'.$geoip))) {
	    $domain .= '['.$geoip.']'; # if geoip disagrees with tld, show both
	}

# Break down the date, check it, and print record

	if ($selectyyyy == -1) {	# "-day all"
	    print "$domain $accessed_dir $userid \[$access_time\] \"$command\" $retcode $size \"$referrer\" \"$browser\"\n";
	} elsif ($access_time =~ /^(.*)\/(.*)\/(.*):(\d\d):(\d\d):(\d\d)(.*)$/) {
	    my $tdd = $1;
	    my $tmmm = $2; # 3 letter abbr
	    my $tyyyy = $3;
	    my $thh = $4;
	    my $tmm = $5;
	    my $tss = $6;
	    my $tzo = $7;
	    if ($tzo =~/ *z/i) { # is timezone offset supplied and just "Z"
		$tzo = 0;	# zulu
	    } elsif ($tzo =~ / *-(\d\d)(\d\d)/) {
		$tzo = (60 * $2) + (60 * 60 * $1); # EDT is -0400
	    } elsif ($tzo =~ / *\+(\d\d)(\d\d)/) {
		$tzo = -(60 * $2) - (60 * 60 * $1);
	    } else {
		$tzo = 0;	# bad offset
	    }
	    # $syst = timegm($tss, $tmm ,$thh, $tdd, $monno{$tmmm}, $tyyyy) + $tzo;
	    # now convert back to localtime .. i guess
	    if (($selectyyyy eq $tyyyy) && ($selectmmm eq $tmmm) && ($selectdd eq $tdd)) { # -- this test is wrong.. $tdd may be GMT but $selectdd is localtime
		print "$domain $accessed_dir $userid \[$access_time\] \"$command\" $retcode $size \"$referrer\" \"$browser\"\n";
	    }
	} else {
	    print "cannot parse $access_time\n";
	}

    } # while <LOG>
    close LOG;
} # process_one_file

# ================================================================
# prettifier for dates
# $val = &twodigit ($field)
# uses global: -
# sets global: -
sub twodigit {			# returns field with leading zero if necessary
    my $x = shift;
    return "$x" if ($x > 9);
    return "0$x";
} # twodigit

# ================================================================
# reversedns(domain) translates numeric URLs into names
# .. caches its result
# $remoteIP = &reversedns($ip, $dnscachefile);
# reads and writes DNS cache file
# globals: $dnscache_nam, $dnscache_arg
use Socket;
sub reversedns {
    my $dom = shift;
    my $dnscachefile = shift;
    my (@adr, $arg, $ali, $typ, $len, @ads);
    my $nam = $dom;
    if ($main::have_read_dns_cache == 0) {
	&readdnscache($dnscachefile);
    }
    if ($main::dnscache_nam{$dom}) {
	$nam = $main::dnscache_nam{$dom}; # found, no need to look
    } else { # not found
	$nam = gethostbyaddr(inet_aton($dom), AF_INET);
	if (($nam eq '') || ($nam eq '.') || (index($nam, '.') == -1) || ($nam =~ /\.woo$/) || ($nam =~ /\.gbl$/)) {
	    $nam = $dom;	# reverse lookup failed or is garbage
	}
 	$main::dnscache_nam{$dom} = $nam; # remember result either way
	$main::dnscache_arg{$dom} = $arg;
    }
    return $nam;
} # reversedns

sub readdnscache {
    my $dnscachefile = shift;
    my ($carg, $cnum, $cnam);
    if (open(DNSCACHE, $dnscachefile)) {
	while (<DNSCACHE>) {
	    chop;
	    ($carg, $cnum, $cnam) = split (/ /, $_);
	    $main::dnscache_nam{$cnum} = $cnam;
	    $main::dnscache_arg{$cnum} = $carg;
	    $main::have_read_dns_cache++;
	} # while
	close (DNSCACHE);
    }
} # readdnscache

sub writednscache {
    my $dnscachefile = shift;
    my ($carg, $cnum, $cnam);
    if (open(DNSCACHE, ">$dnscachefile")) {
	foreach (keys %main::dnscache_nam) {
	    $cnam = $main::dnscache_nam{$_};
	    $carg = $main::dnscache_arg{$_};
	    print DNSCACHE "$carg $_ $cnam\n";
	} # foreach
	close (DNSCACHE);
    }
} # writednscache

# ----------------------------------------------------------------
# Look up city/state/country for an address, either IP or domain.
# .. do not do a DNS lookup to translate the address into an IP to look it up, too slow.
# .. if the domain name has 4 numeric strings like an IP inside it, use that.
#    $result = &lookup_super_geoip($addr, \%values);
# .. region is state/province code, ISO/FIPS
# .. postalcode is blank or numeric for many non-us countries
# .. dmacode is a number, has to do with US TV station markets
#
# 08/23/18 new maxmind database format
#
# returns a suffix for the domain, or null if can't match an IP
# Globals: %geoipcache
use Geo::IP::PurePerl;
use GeoIP2::Database::Reader;
use Try::Tiny;

sub lookup_super_geoip {
    my $dom = shift;
    my $vp = shift;
    my $geoip_version = 'GeoLite2' if $geoip_citydatafile =~ /mmdb$/; # new way
    my $result = '';
    # same code as in thvvutil::citylookup
    # some ISPs encode the IP address BACKWARDS in the reverse DNS name
    my $ok = 0;
    if ($dom =~ /([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})\.in-addr\.arpa/) { 
	$dom = "$4.$3.$2.$1";	# backwards
	$ok = 1;
    } elsif ($dom =~ /([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})\.airtel\.in/) {
	$dom = "$4.$3.$2.$1";	# backwards
	$ok = 1;
    } elsif ($dom =~ /([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})\.airtelbroadband\.in/) {
	$dom = "$4.$3.$2.$1";	# backwards
	$ok = 1;
    } elsif ($dom =~ /([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})\.cust\.bluewin\.ch/) {
	$dom = "$4.$3.$2.$1";	# backwards
	$ok = 1;
    } elsif ($dom =~ /([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})[-\.]([0-9]{1,3})/) { # this will match embedded IPs also
	$dom = "$1.$2.$3.$4";	# forwards
	$ok = 1;
    }
    if ($ok == 1) {
	if ($main::geoipcache{$dom}) {      # in cache?
	    return $main::geoipcache{$dom}; # yes
	}
	# calculate a domain name suffix: either [cc] or [cc/city] or [cc/city state]
	if ($geoip_version eq 'GeoLite2') {
	    #warn "$me: using Geolite2 $dom\n";
	    # new way .. does not set as many variables unless you buy Insights service
	    try {
		my $reader = GeoIP2::Database::Reader->new(file => $geoip_citydatafile, locales => [ 'en', ]);
		my $cr = $reader->city( ip => $dom );
		my $cityrec = $cr->city();
		my $cityname = $cityrec->name();
		#warn "$me: cityname $cityname\n";
		my $countryrec = $cr->country();
		my $country_code = $countryrec->iso_code();
		#warn "$me: country_code $country_code\n";
		my $mss = $cr->most_specific_subdivision();
		my $region = $mss->iso_code() if defined ($mss); # check if this works
		#warn "$me: region $region\n";
		my $regionid = '';
		$regionid = $region if $country_code eq 'US'; # only show state/province for US/CA
		$regionid = $region if $country_code eq 'CA';
		if ($country_code ne '') {
		    $country_code =~ tr/A-Z/a-z/;
		    $result .= $country_code;
		    if ($cityname ne '') {
			$result .= '/';
			$result .= $cityname;
			if ($regionid ne '') {
			    $result .= ' '. $regionid;
			}
		    }
		}
	    } catch {
		# GeoIP2::Error::Generic or GeoIP2::Error::IPAddressNotFound 
		$result = "";
	    }		
	} else { # doing this the PurePerl way, no longer updated after April 2018
	    #warn "$me: using GeoLiteCity $dom\n";
	    my $gi = Geo::IP::PurePerl->new($geoip_citydatafile, GEOIP_STANDARD);
	    my ($country_code,$country_code3,$country_name,$region,$city,$postal_code,$latitude,$longitude,$dma_code,$area_code) = $gi->get_city_record($dom);
	    $country_code =~ tr/A-Z/a-z/;
	    $result = $country_code;
	    if ($city ne '') {
		$result .= '/';
		$result .= $city;
		if (($country_code eq 'us')||($country_code eq 'us')) {
		    $result .= ' ' if $region ne ''; # stick on the state if it is US
		    $result .= $region;
		}
	    }
        }
	$result =~ s/\'/\&#39;/g; # change apostrophe to escape to prevent SQL failure
	$result =~ s/ /+/g;	# don't mess up the parse in logvisits.pl
	$result =~ s/[^[:ascii:]]+/?/g;  # get rid of non-ASCII characters .. silence 'wide character in print' for hungarian etc
	$main::geoipcache{$dom} = $result;
    } else {
	$result = "";
    }
    return $result;
} # lookup_super_geoip
